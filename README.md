# GitHub commands

## КОМАНДЫ

- **Посмотреть Все Установленные Настройки и узнать где они заданы:**
    ` git config --list --show-origin `

* * * 

- **Инициализация / Создание репозитория в существующем каталоге:**
    
    - Переходим в каталог с проектом и выполняем:
       ` git init `

Примечание: в текущем каталоге создаётся новый подкаталог с именем .git, содержащий все необходимые файлы репозитория — структуру Git репозитория. На этом этапе проект ещё не находится под версионным контролем.
!! Не рекомендуется создавать репозиторий Git внутри другого Git-репозитория. Это может вызывать проблемы с отслеживанием изменений.

* * * 

- **«Разгитить» папку, если что-то пошло не так**
`rm -rf .git`
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку `.git`
`cd <папка с репозиторием>`   # перешли в папку
`rm -rf .git`  # удалили подпапку .git 

В подпапке `.git` хранится история изменений. Если удалить `.git`, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

* * * 

- **Добавить под Версионный Контроль Измененные/Созданные файлы в Индекс (состояние staged) (После того как файл был изменен/создан, он переходит в состояние modified):**

`git add name_file`  - добавить в индекс конкретный файл в репозитории
или  
`git add --all` - добавить в индекс все файлы в репозитории
или
`git add * . ` - добавить в индекс всю текущую папку
Можно использовать любой из этих вариантов — результат будет одинаковый.

Примечание:
--Если имя файла не указано, то добавятся Все Измененные/Вновь_Созданные файлы.
--После КАЖДОГО Изменения файла, необходимо добавлять его в Индекс (git add name_file). Т.е. если файл уже был добавлен в Индекс (git add, но не был сделан commit), а потом файл Снова Изменили, то ОБЯЗАТЕЛЬНО опять добавляем его в Индекс (git add) и только потом делаем git commit. В противном случае в репозиторий не запишутся последние изменения, которые не были проиндексированы.

* * * 

- **ПРОСМОТР СОСТОЯНИЯ / СТАТУСА файлов в рабочем каталоге:**
	`git status`

- **Сокращённый вывод статуса:**
` git status -s или git status --short `
?? - новые неотслеживаемые файлы,
A - файлы, добавленные в отслеживаемые
M - модифицирован и проиндексирован
M - модифицирован, но не проиндексирован
MM - модифицирован, проиндексирован и ещё раз модифицирован (есть изменения, которые попадут в коммит, и изменения, которые не попадут в коммит)

* * *

**ПРОСМОТР Истории Коммитов**
` git log `

Примечание: по умолчанию (без аргументов) git log перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке — последние коммиты находятся вверху. Данная команда перечисляет коммиты с их SHA-1 контрольными суммами, именем и электронной почтой автора, датой создания и сообщением коммита.

- ПРОСМОТР Истории определенной ветки:
`git log Имя_Ветки`

- ПРОСМОТР Истории Всех веток:
`git log --all`

- ПРОСМОТР где стоит указатель `HEAD` :
`git log --oneline --decorate`



**Опции (Наиболее распространённые):**
```
Таблица 1. Наиболее распространённые опции для команды git log

Опция			Описание

-p			Показывает патч (подробное описание) для каждого коммита.
--stat			Показывает статистику изменённых файлов для каждого коммита.
--shortstat		Отображает только строку с количеством изменений/вставок/удалений для команды --stat.
--name-only		Показывает список изменённых файлов после информации о коммите.
--name-status		Показывает список файлов, которые добавлены/изменены/удалены.
--abbrev-commit		Показывает только несколько символов SHA-1 чек-суммы вместо всех 40.
--relative-date		Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты.
--graph			Отображает ASCII граф с ветвлениями и историей слияний.
--pretty		Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней можно указать свой формат).
--oneline		Сокращение для одновременного использования опций --pretty=oneline --abbrev-commit.

```

Остальные Опции - смотри в "GIT - ТЕОРИЯ / СТРУКТУРА / Команды"

- **ПРОСМОТР Подробной Информации об Объекте**
`git show`

- **ПРОСМОТР Подробной Информации о Коммите**
`git show хэш_коммита`

* * *

## ПРОСМОТР ИЗМЕНЕНИЙ

- **ПОСМОТРЕТЬ разницу между последним коммитом и текущим состоянием файлов (Покажет Ваши изменения в файлах)**
`git diff`
q
- **Посмотреть, что проиндексировали и собираемся включить в коммит.** 
`git diff --staged  (--staged и --cached синонимы)` 

* * * 

## ЗАКОММИТИТЬ / Записать изменения в Репозиторий

- **Записать изменения в репозиторий (ключ -m - указать сообщение коммита вида "...." ):**
` git commit -m "my first commit" ` 

- **Запись Изменений в Репозиторий с Одновременной Записью в Индекс (git add) :**
` git commit -am  'Мой коммит'  `

-a - запись в Индекс (Индексирование)

![ce053218576075f34cf9b36a7f0802bd.png](:/680eb68d833248e18878094cd3019372)
- ПРИМЕЧАНИЕ: Команда `git commit` после выполнения выводит информацию о коммите.
	- `[master (root-commit) baa3b6e]` значит:
		- коммит был в ветке `master`;
		- `root-commit` — это самый первый, или «корневой» (англ. root), коммит в ветке, у следующих коммитов такой надписи не будет;
		- `baa3b6e` — сокращённый идентификатор коммита.
	- `2 files changed, 1 insertion(+)` значит:
		- изменились два файла (`readme.txt и todo.txt`);
		- одна строка была добавлена.
	- Строки вида `create mode 100644 readme.txt` — это более подробная информация о новых (добавленных в Git) файлах.
		- `create` (англ. «создать») говорит, что файл был создан. Если бы файл был удалён, на этом месте было бы слово `delete` (англ. «удалить»).
		- `mode 100644` сообщает, что это обычный файл (права 644). 
		- Также возможны варианты `100755` для исполняемых файлов (например, что-нибудь.exe) и `120000` для файлов-ссылок в Linux (сим-линки). Файлы-ссылки не содержат данных сами по себе, а только ссылаются на другие файлы — как «ярлыки» в Windows.


* * * 

## ОТМЕНА Изменений / ВОССТАНОВЛЕНИЕ Файлов: restore / reset

### Отмена Индексации Файла: git reset / git restore

- **Отмена Индексации / Исключить из Индекса  файл: git restore**
Начиная с версии 2.23.0, Git будет использовать git restore вместо git reset для многих операций отмены.
Предположим, что вы изменили два файла и хотите зафиксировать их как два отдельных изменения, но случайно набираете git add * и индексируете их оба. 
Убрать из индекса один из файлов (git status - выводит подсказку какубю команду использовать): 
` git restore --staged <file> `

- **ОТМЕНА Изменений в Файле, НЕ Внесённого в ИНДЕКС: git restore**
Например изменили сам файл (сами изменения НЕ внесли в индекс (НЕ выполнили git add), но НЕ хотите сохранять изменения в файле, то эти изменения можно откатить — вернуть обратно к тому, как он выглядел при последнем коммите (или изначально клонирован, или каким-либо образом помещён в рабочий каталог). Команда git status подсказывает как это сделать:
` git restore  <file> `  

ПРИМЕЧАНИЕ: git restore file — опасная команда. Любые локальные изменения, внесённые в этот файл, исчезнут — Git просто заменит файл последней зафиксированной версией. Никогда не используйте эту команду, если точно не знаете, нужны ли вам эти несохранённые локальные изменения.


- **Отмена Индексации файла: git reset**
Например, изменили два файла и хотите добавить их в разные коммиты, но случайно выполнили команду git add * и добавили в индекс оба. Исключаем из индекса оределенный файл:
` git reset HEAD file_name `
Примечание: Команда git reset может быть опасной если вызвать её с параметром --hard. 

- ПЕРЕДВИНУТЬ Указатель Ветки (HEAD), на который указывает в данной момент
HEAD, на определенный коммит. Например, если необходимо откатить ветку на коммит 660503:
`git reset --hard 660503`  - С ОСТОРОЖНОСТЬЮ!!! 

Примечание: Параметр hard говорит git передвинуть ветку, даже если в рабочем каталоге или индексе есть какие-то изменения.

* * * 

## УДАЛЕНИЕ Файлов / Каталогов / Шаблонов: git rm
Для того чтобы удалить файл из Git, необходимо удалить его из отслеживаемых файлов (точнее, удалить его из вашего индекса) а затем выполнить коммит. Это позволяет сделать команда git rm, которая также удаляет файл из вашего рабочего каталога, так что в следующий раз вы не увидите его как «неотслеживаемый».

- **УДАЛИТЬ файл/каталог, который НЕ в Индексе (Untracked files)**
`rm -rf  имя_файла  или  имя_каталога`

- **УДАЛИТЬ файл из Индекса и из Рабочего Каталога**
` git rm имя_файла `

- **Принудительное Удаление файла из Индекса и из Рабочего Каталога**
` git rm -f имя_файла `

-f - принудительное удаление файла из индекса, т.е. используется если вы изменили файл и уже проиндексировали его. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git.

- **УДАЛИТЬ Файл из ИНДЕКСА, но ОСТАВИТЬ его в РАБОЧЕМ КАТАЛОГЕ.** 
` git rm --cached имя_файла `  или  ` git rm --staged имя_файла ` 

Примечание:
Оставить файл на жёстком диске, но перестать отслеживать изменения в нём? при этом файл попадет в untracked. Это особенно полезно, если вы забыли добавить что-то в файл .gitignore и по ошибке проиндексировали, например, большой файл с логами, или кучу промежуточных файлов компиляции. 


- **Удаление Файлов, Каталогов или Шаблонов.** 
	- **Удалить Все файлы, имеющие расширение .log и находящиеся в каталоге log/.** 
` git rm log/\*.log `
Примечание: 
Обратный слеш (\) перед *. необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику вашего командного интерпретатора.
	
	- **Удалить Все Файлы, имена которых заканчиваются на ~.**
` git rm \*~  `
	
	- ЕЩЁ ПРИМЕРЫ...... Дописать



* * * 

## ПЕРЕМЕЩЕНИЕ / ПЕРЕИМЕНОВАНИЕ файлов
Git не отслеживает перемещение файлов явно. Когда вы переименовываете файл в Git, в нём не сохраняется никаких метаданных, говорящих о том, что файл был переименован. 

Команда `git mv` заменяет три команды (mv, git rm, git add).

- **ПЕРЕИМЕНОВАТЬ файл:**
` git mv file_from  file_to `

**ПЕРЕМЕСТИТЬ в каталог и Переименовать файл :**
` git mv file_from  ./dir/file_to `

Если выполнить команду выше и посмотреть статус, увидим, что Git считает, что произошло переименование файла.
![e15e36bc913517c097b275d47dff5070.png](:/f30ab95c58c74255b4501b41198dcfff)

Это эквивалентно выполнению следующих команд:
![251dfa312c001e392e7e1cb890cee67d.png](:/2a34cde0c6344fa6853e56608489bc76)

Git неявно определяет, что произошло переименование, поэтому неважно, переименуете вы файл так или используя команду mv. Единственное отличие состоит лишь в том, что git mv — одна команда вместо трёх — это функция для удобства.


* * * 
* * *

## ВЕТКИ / BRANCH

## ПРОСМОТР / СОЗДАНИЕ / УДАЛЕНИЕ  Веток: git branch

- **ПРОСМОТР Веток в Локальном Репозитории**
`git branch`

- **ПРОСМОТР ВСЕХ Веток в Репозитории (в Удаленном тоже)**
`git branch -a`
`git branch --all`



- **СОЗДАТЬ Новую Ветку и перейти на неё:** 
`git checkout -b develop`
ИЛИ
`git switch -c Имя_Новой_Ветки`
 -b -создать новую ветку 
 -c -создать новую ветку
Начиная с Git версии 2.23, можно использовать git switch вместо git checkout, чтобы переключиться на другую ветку. 

ИЛИ (в Три Команды)

- Смотрим на какой ветке находимся:
	 `git branch`
	 - Создаём ветку  develop:
	 		`git branch develop`	
	 - Перейдём на ветку develop 
			 `git checkout  develop`


- **УДАЛИТЬ Ветку в Локальном Репозитории**
`git branch -d branch-name`
При этом ветка должна быть либо смержена в другую, либо запушена в удаленный репозиторий, иначе удаление пройдет с ошибкой. 

- **УДАЛИТЬ Ветку в Локальном Репозитории, которая НЕ Смержена и НЕ Запушена в Удален-й Репо-й**
`git branch -D branch-name`


- **УДАЛИТЬ Ветку в УДАЛЕННОМ Репозитории (ветка должна быть смержена, иначе будет ошибка):**
`git push origin --delete branch-name`


* * * 

## ПЕРЕКЛЮЧЕНИЕ / СОЗДНИЕ ВЕТОК / ОТМЕНА ИЗМЕНЕНИЙ: git checkout

- **ПЕРЕКЛЮЧИТЬСЯ на ветку master:**
`git checkout master`
`git switch master`
Начиная с Git версии 2.23, можно использовать git switch вместо git checkout, чтобы переключиться на другую ветку. 

- **СОЗДАТЬ Новую Ветку new-api и перейти на нее:**
`git checkout -b new-api`
`git switch -c master`
-c (--create) - создать новую ветку переключиться на неё

- **ОТМЕНИТЬ Изменения, сделанные в файле main.java:**
`git checkout -- main.java`  (аналог git restore)

- **ОТМЕНИТЬ ВСЕ Изменения, которые НЕ Попали в КОММИТ, для ВСЕХ Файлов и Перейти на Ветку master:**
`git checkout -f master`   - С ОСТОРОЖНОСТЬЮ!!!

ПРИМЕЧАНИЕ: 
При выполнение git checkout указатели веток никак НЕ меняются

- **Перейти на Определенный Коммит, зная его ХЭШ, при этом состояние Рабочего Каталога Изменится на Состояние Коммита и получится состояние `detach head`:**
`git checkout b8cb53`

- **Переключиться на Новую Ветку, которая есть в Удаленном Репозитории, но нет у Вас Локально**
	- Скачиваем изменения с удаленного репозитория:
	` git pull --rebase`
	--rebase - всегда забираем изменения из удаленного репозитория с этим ключом, т.к. коллеги могут запушить в этот Репозиторий свои правки.

	- Переходим на новуб ветку (которую только что скачали):
	` git checkout develop `

* * *

## ПЕРЕИМЕНОВАНИЕ ВЕТКИ

https://www.git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B5%D1%82%D0%BA%D0%B0%D0%BC%D0%B8

Предположим, есть ветка с именем old-branch-name, и необходимо изменить её на new-branch-name, сохранив при этом всю историю. Вместе с этим, вы также хотите изменить имя ветки на удалённом сервере (GitHub, GitLab или другой сервер). ШАГИ:

- Переименуйте ветку локально с помощью команды git branch --move:
`git branch --move old-branch-name new-branch-name`
Ветка old-branch-name будет переименована в new-branch-name, но это изменение пока только локальное. 

- Запушим исправленную ветку в удалённый репозиторий (В удаленном репозитории создастся новая ветка с именем `new-branch-name`, которая будет связана с текущей венткой в локальном репозитории):
`git push -u origin new-branch-name`
или
`git push --set-upstream origin new-branch-name`

- Посмотрим ВСЕ Ветки (включая удаленные):
`git branch --all`
```
* new-branch-name
  main
  remotes/origin/old-branch-name
  remotes/origin/new-branch-name
  remotes/origin/main
```
ПРИМЕЧАНИЕ:
Обратите внимание, что текущая ветка new-branch-name, которая также присутствует и на удалённом сервере. Однако, старая ветка всё ещё по-прежнему там, но её можно удалить:
`git push origin --delete old-branch-name`
Теперь старое имя ветки полностью заменено исправленным.


* * * 

## HESH

- `Хеш` — основной идентификатор коммита
	- Git хранит таблицу соответствий хеш → информация о коммите. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.
	- При работе с Git хеши будут встречаться вам регулярно. Их можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким коммитом нужно произвести то или иное действие.
	- Все хеши и таблицу хеш → информация о коммите Git сохраняет в служебные файлы. Они находятся в скрытой папке .git в репозитории проекта.


* * * 


